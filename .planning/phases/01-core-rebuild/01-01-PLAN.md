---
phase: 01-core-rebuild
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/hook/package.json
  - packages/hook/src/types.ts
  - packages/hook/src/lib/constants.ts
  - packages/hook/src/lib/config.ts
  - packages/hook/src/lib/registry.ts
  - packages/hook/src/lib/output.ts
  - packages/hook/src/lib/io.ts
  - packages/hook/src/lib/utils.ts
  - packages/hook/src/checkers/plugins.ts
  - packages/hook/src/index.ts
autonomous: true

must_haves:
  truths:
    - "Hook loads and validates dependencies.yaml with new nested schema (version: 1, plugins/cli/mcp sections)"
    - "Hook checks plugin dependencies against installed_plugins.json registry"
    - "Hook outputs systemMessage with missing dependency details (name + description + install command)"
    - "Hook outputs empty object {} when all dependencies are installed"
    - "Hook never crashes — always outputs valid JSON even on malformed config, missing files, or unexpected errors"
    - "All control flow uses ts-pattern match().with().exhaustive() — zero ternaries, zero nested conditionals"
    - "All async operations use attemptAsync — zero try-catch blocks"
  artifacts:
    - path: "packages/hook/src/types.ts"
      provides: "Shared type definitions for new schema (DependenciesConfig, EcosystemSection, PluginDependency, ValidationResult as discriminated union)"
      contains: "version: 1"
    - path: "packages/hook/src/lib/config.ts"
      provides: "Config loading (confbox multi-format) and validation (ts-pattern discriminated unions)"
      contains: "attemptAsync"
    - path: "packages/hook/src/checkers/plugins.ts"
      provides: "Plugin dependency checking against installed_plugins.json"
      contains: "match"
    - path: "packages/hook/src/lib/output.ts"
      provides: "systemMessage formatting with install commands"
      contains: "formatMissing"
    - path: "packages/hook/src/index.ts"
      provides: "Entry point with top-level attemptAsync wrapper"
      contains: "attemptAsync"
  key_links:
    - from: "packages/hook/src/index.ts"
      to: "packages/hook/src/lib/config.ts"
      via: "loadConfig + validateConfig calls"
      pattern: "loadConfig|validateConfig"
    - from: "packages/hook/src/index.ts"
      to: "packages/hook/src/checkers/plugins.ts"
      via: "checkPlugins call"
      pattern: "checkPlugins"
    - from: "packages/hook/src/index.ts"
      to: "packages/hook/src/lib/output.ts"
      via: "formatResponse call"
      pattern: "formatResponse|buildHookResponse"
    - from: "packages/hook/src/lib/config.ts"
      to: "packages/hook/src/types.ts"
      via: "ValidationResult discriminated union"
      pattern: "ValidationResult"
---

<objective>
Rebuild the hook package from scratch with proper patterns (ts-pattern, attemptAsync, es-toolkit) and the new nested schema supporting three ecosystems.

Purpose: The hook is the foundation — it runs inside Claude Code when a plugin loads and must never crash. It must validate the new nested dependencies.yaml schema (version: 1 with plugins/cli/mcp sections), check plugin installations against the registry, and output actionable systemMessages for missing dependencies.

Output: Complete `packages/hook` package rebuilt from scratch — types, config loading/validation, plugin checking, output formatting, and crash-proof entry point. Builds to `dist/anthropak.mjs`.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-rebuild/01-CONTEXT.md
@.planning/phases/01-core-rebuild/01-RESEARCH.md

Reference existing code for understanding build setup, environment variables, and registry format:
@packages/hook/tsdown.config.ts
@packages/hook/tsconfig.json
@packages/hook/package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Types, constants, and config loading/validation</name>
  <files>
    packages/hook/package.json
    packages/hook/src/types.ts
    packages/hook/src/lib/constants.ts
    packages/hook/src/lib/config.ts
  </files>
  <action>
**Add dependencies to packages/hook/package.json:**
Add `ts-pattern` (^5.5.0) and `es-toolkit` (^1.44.0) to dependencies alongside existing `confbox`. Then run `pnpm install` from the repo root.

**Rewrite packages/hook/src/types.ts from scratch:**
Define the new nested schema types per CONTEXT.md locked decisions:

- `DependenciesConfig` — top-level with `version: 1` (literal type), optional `plugins?: EcosystemSection`, optional `cli?: EcosystemSection`, optional `mcp?: EcosystemSection`
- `EcosystemSection` — `required: DependencyEntry[]`, `optional: DependencyEntry[]`
- `PluginDependency` — `plugin: string` (required), `github?: string`, `install?: string`, `description?: string`. No `marketplace` field (dropped per CONTEXT.md).
- `DependencyEntry` — for Phase 1, this is the same as PluginDependency. CLI and MCP entries will extend in later phases. Use a type alias: `type DependencyEntry = PluginDependency`
- `ValidationResult` as discriminated union:
  - `{ status: 'success'; config: DependenciesConfig }`
  - `{ status: 'not_found' }`
  - `{ status: 'parse_error'; message: string }`
  - `{ status: 'validation_error'; errors: string[] }`
- `ConfigLoadResult` — same discriminated union as ValidationResult (reuse or alias)
- `InstalledPluginsRegistry` — `{ plugins: Record<string, PluginInstallation[]> }`
- `PluginInstallation` — `{ scope: 'global' | 'project'; projectPath?: string }`
- `HookResponse` — `{ systemMessage?: string }`
- `CheckResult` — `{ missingRequired: PluginDependency[]; missingOptional: PluginDependency[] }`

Export all types. These are the source of truth for the CLI package too.

**Rewrite packages/hook/src/lib/constants.ts from scratch:**
- `CONFIG_FILES` array with objects `{ name: string; format: 'yaml' | 'json' | 'jsonc' }` for dependencies.yaml, dependencies.yml, dependencies.json, dependencies.jsonc
- `DEFAULT_REGISTRY: InstalledPluginsRegistry` — `{ plugins: {} }`
- `PLUGIN_ROOT` — from `process.env.CLAUDE_PLUGIN_ROOT` or derive from `import.meta.url` (two levels up from lib/)
- `PROJECT_DIR` — from `process.env.CLAUDE_PROJECT_DIR` or `process.cwd()`
- `INSTALLED_PLUGINS_PATH` — `join(homedir(), '.claude', 'plugins', 'installed_plugins.json')`

**Rewrite packages/hook/src/lib/config.ts from scratch:**
This file handles loading config files and validating against the new schema. Use `attemptAsync` for all file reads and parsing. Use `ts-pattern` for all control flow.

`loadConfig(rootDir: string): Promise<ConfigLoadResult>`:
- Loop through CONFIG_FILES, for each: use `attemptAsync` to read file with `fs/promises readFile`
- If read error, continue to next file (file doesn't exist)
- If read succeeds, use `attemptAsync` to parse with confbox (`parseYAML`, `parseJSON`, `parseJSONC`) based on format field. Use `match(format).with('yaml', ...).with('json', ...).with('jsonc', ...).exhaustive()` to select parser.
- If parse error, return `{ status: 'parse_error', message: error.message }`
- If parse succeeds, call `validateConfig(raw)` and return result
- If no files found, return `{ status: 'not_found' }`

`validateConfig(raw: unknown): ValidationResult`:
- Use ts-pattern to check structure. Do NOT use nested if/else.
- Check `typeof raw === 'object' && raw !== null` — if not, return validation_error
- Check `version` field exists and equals `1` — if missing, return `{ status: 'validation_error', errors: ['Missing required field: version'] }`. If wrong value, return appropriate error.
- Check at least one ecosystem section present (plugins, cli, mcp) — per CONTEXT.md: "All sections optional, but at least one must be present"
- For each present section, validate it has the right shape: `{ required: array, optional: array }` where arrays default to empty if missing
- For plugins section specifically, validate each entry has `plugin` (string, non-empty). Optional fields (`github`, `install`, `description`) must be strings if present.
- cli and mcp sections: validate structure only (required/optional arrays), don't validate individual entries deeply yet (Phase 2/3)
- Return `{ status: 'success', config }` with properly typed DependenciesConfig on success

IMPORTANT: Zero try-catch. Zero ternaries. Zero nested if/else beyond the simplest single-level checks. Use `match()` for branching, `attemptAsync` for error handling.
  </action>
  <verify>
Run `pnpm typecheck` from packages/hook — should pass with zero errors. Verify no try-catch blocks exist: `grep -r "try {" packages/hook/src/` should return nothing. Verify no ternaries: `grep -rn "?" packages/hook/src/types.ts packages/hook/src/lib/config.ts packages/hook/src/lib/constants.ts | grep -v "optional\|?:"` should show only optional chaining, not ternary operators.
  </verify>
  <done>
types.ts defines new nested schema with discriminated union ValidationResult. config.ts loads multi-format config with attemptAsync and validates with ts-pattern. constants.ts provides config file list and environment paths. All use proper patterns — zero try-catch, zero ternaries, zero nested conditionals.
  </done>
</task>

<task type="auto">
  <name>Task 2: Plugin checker, output formatting, and crash-proof entry point</name>
  <files>
    packages/hook/src/checkers/plugins.ts
    packages/hook/src/lib/output.ts
    packages/hook/src/lib/registry.ts
    packages/hook/src/lib/io.ts
    packages/hook/src/lib/utils.ts
    packages/hook/src/index.ts
  </files>
  <action>
**Delete packages/hook/src/lib/utils.ts** — the `safeParse` function will be replaced by attemptAsync + JSON.parse pattern. No custom utilities.

**Rewrite packages/hook/src/lib/io.ts from scratch:**
Keep only `readStdin` function but rewrite with attemptAsync:
- Read stdin data into a string buffer
- Parse JSON with attemptAsync
- Return the parsed data or null on error
- Do NOT use try-catch

**Rewrite packages/hook/src/lib/registry.ts from scratch:**
`loadInstalledPlugins(registryPath: string): Promise<InstalledPluginsRegistry>`:
- Use `attemptAsync` to read file with `fs/promises readFile`
- Use `attemptAsync` to parse JSON
- If any error, return `DEFAULT_REGISTRY`
- No try-catch, no readFileSync

`isPluginInstalled(registry, pluginName, projectDir): boolean`:
- Check if any plugin key in registry starts with `${pluginName}@`
- For matching keys, check if any installation covers the project using ts-pattern `match(inst).with({ scope: 'global' }, ...).with({ scope: 'project' }, ...).exhaustive()`
- A project-scoped installation covers if `projectDir === inst.projectPath` or `projectDir.startsWith(inst.projectPath + '/')`

**Create packages/hook/src/checkers/plugins.ts (NEW file in new directory):**
`checkPlugins(config: DependenciesConfig, registry: InstalledPluginsRegistry, projectDir: string): CheckResult`:
- If `config.plugins` is undefined, return `{ missingRequired: [], missingOptional: [] }`
- Filter `config.plugins.required` to find entries where `isPluginInstalled` returns false
- Filter `config.plugins.optional` to find entries where `isPluginInstalled` returns false
- Return `{ missingRequired, missingOptional }`
- Use ts-pattern if there are conditional branches

**Rewrite packages/hook/src/lib/output.ts from scratch:**
`getInstallCommand(dep: PluginDependency): string`:
- Use `match()` to determine install command. Priority: `dep.install` (custom) > `dep.github` (git clone) > fallback (`claude plugin add ${dep.plugin}`)
- Pattern: match on which fields are present using P.string guards
- No marketplace (dropped per CONTEXT.md)

`formatMissingDependencies(missing: PluginDependency[], required: boolean): string`:
- Header: "**Missing Required Plugin Dependencies**" or "**Missing Optional Plugin Dependencies**"
- Per dep: `- **{plugin}**` + optional description + install command line

`buildHookResponse(checkResult: CheckResult): HookResponse`:
- Use `match()` to handle cases: both empty = `{}`, has missing = build systemMessage
- Group by required/optional (Claude's discretion choice: required first, more actionable)
- Per CONTEXT.md: empty object `{}` when everything installed (completely silent)

**Handle error messages for non-success config states:**
`buildErrorResponse(loadResult: ConfigLoadResult): HookResponse`:
- Use `match(loadResult)` with `.with({ status: 'not_found' }, ...)` returning hint about `anthropak init`
- `.with({ status: 'parse_error' }, ...)` returning generic warning about `anthropak validate`
- `.with({ status: 'validation_error' }, ...)` returning generic warning about `anthropak validate`
- Per CONTEXT.md: "Malformed config: warn in systemMessage", "No config file: hint in systemMessage"

**Rewrite packages/hook/src/index.ts from scratch:**
Entry point with top-level attemptAsync crash protection:
```
(async () => {
  const [error, response] = await attemptAsync(async () => {
    // 1. Read stdin (hook receives context from Claude Code)
    await readStdin();

    // 2. Load and validate config
    const loadResult = await loadConfig(PLUGIN_ROOT);

    // 3. Match on result — success path checks deps, other paths return error messages
    return match(loadResult)
      .with({ status: 'success' }, async ({ config }) => {
        const registry = await loadInstalledPlugins(INSTALLED_PLUGINS_PATH);
        const checkResult = checkPlugins(config, registry, PROJECT_DIR);
        return buildHookResponse(checkResult);
      })
      .with({ status: 'not_found' }, () => buildErrorResponse(loadResult))
      .with({ status: 'parse_error' }, () => buildErrorResponse(loadResult))
      .with({ status: 'validation_error' }, () => buildErrorResponse(loadResult))
      .exhaustive();
  });

  // Crash protection: always output valid JSON
  const output = error ? {} : response;
  console.log(JSON.stringify(output));
  process.exit(0);
})();
```

Note: The outer `attemptAsync` is the ONE place where we catch everything — this ensures the hook never crashes per CONTEXT.md. The inner match handles known states exhaustively.

IMPORTANT: Zero try-catch anywhere in the hook package. Zero ternaries. All control flow through ts-pattern match(). The only `if` statements allowed are simple guard checks (checking for null/undefined before accessing a property), never nested.
  </action>
  <verify>
Run `pnpm typecheck` from packages/hook — should pass with zero errors. Run `pnpm build` from packages/hook — should produce dist/anthropak.mjs. Verify zero try-catch: `grep -rn "try {" packages/hook/src/` returns nothing. Verify zero ternaries: `grep -rn " ? " packages/hook/src/ | grep -v "\/\/" | grep -v "\.d\.ts"` returns nothing (excluding comments and declaration files). Verify utils.ts is deleted. Verify checkers/ directory exists with plugins.ts.
  </verify>
  <done>
Complete hook package rebuilt from scratch. Plugin checker in new checkers/ directory. Output formatting with install commands. Registry loading with attemptAsync. Crash-proof entry point with top-level attemptAsync wrapper. Zero try-catch, zero ternaries, zero nested conditionals across entire package. Builds successfully to dist/anthropak.mjs.
  </done>
</task>

</tasks>

<verification>
1. `pnpm typecheck` passes in packages/hook with zero errors
2. `pnpm build` in packages/hook produces dist/anthropak.mjs
3. `grep -rn "try {" packages/hook/src/` returns zero matches (no try-catch)
4. `grep -rn "catch" packages/hook/src/` returns zero matches (no catch blocks)
5. ts-pattern `match` is used in config.ts, registry.ts, output.ts, index.ts, and checkers/plugins.ts
6. `attemptAsync` is used for all file reads, JSON parsing, and the top-level entry point wrapper
7. New schema types define `version: 1`, `plugins/cli/mcp` sections, no `marketplace` field
8. ValidationResult is a discriminated union with status field
</verification>

<success_criteria>
- Hook package builds to dist/anthropak.mjs with zero TypeScript errors
- All control flow uses ts-pattern match().with().exhaustive() — zero ternaries, zero nested if/else
- All async error handling uses attemptAsync — zero try-catch blocks
- New nested schema types defined (version: 1, plugins/cli/mcp with required/optional arrays)
- Hook never crashes — top-level attemptAsync ensures valid JSON output on any error
- Plugin dependencies checked against installed_plugins.json registry
- Missing dependencies reported with name + description + install command
- Empty object {} returned when all dependencies installed
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-rebuild/01-01-SUMMARY.md`
</output>
