---
phase: 01-core-rebuild
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/hook/src/lib/output.ts
  - packages/hook/src/lib/config.ts
  - packages/hook/src/index.ts
  - packages/cli/src/lib/config-loader.ts
  - packages/cli/src/commands/init.ts
  - packages/cli/src/commands/update.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Zero ternary operators exist in packages/hook/src/ and packages/cli/src/"
    - "All control flow uses ts-pattern match().with().exhaustive() or .otherwise()"
    - "Build succeeds with no type errors after ternary replacements"
  artifacts:
    - path: "packages/hook/src/lib/output.ts"
      provides: "Header and description formatting via match()"
      contains: "match(required)"
    - path: "packages/hook/src/lib/config.ts"
      provides: "Error message extraction via match()"
      contains: "match(parseError)"
    - path: "packages/hook/src/index.ts"
      provides: "Crash-proof output selection via match()"
      contains: "match({ error, response })"
    - path: "packages/cli/src/lib/config-loader.ts"
      provides: "Error message extraction via match()"
      contains: "match(parseError)"
    - path: "packages/cli/src/commands/init.ts"
      provides: "File action and reason formatting via match()"
      contains: "match(hookScriptExists)"
    - path: "packages/cli/src/commands/update.ts"
      provides: "File action and reason formatting via match()"
      contains: "match(hookScriptExists)"
  key_links:
    - from: "packages/hook/src/lib/output.ts"
      to: "ts-pattern"
      via: "match() import"
      pattern: "import.*match.*from.*ts-pattern"
    - from: "packages/hook/src/index.ts"
      to: "ts-pattern"
      via: "match() for output selection"
      pattern: "match.*error.*response"
---

<objective>
Replace all 9 remaining ternary operators with ts-pattern match() expressions to achieve 100% HARD-01 compliance (zero ternaries, zero nested conditionals).

Purpose: Close the single verification gap from 01-VERIFICATION.md. HARD-01 requires ALL control flow to use ts-pattern. 9 ternaries violate this. Replacing them completes Phase 1.

Output: 6 files updated, zero ternaries remaining, build passes.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-rebuild/01-VERIFICATION.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace ternaries in hook package (4 ternaries in 3 files)</name>
  <files>
    packages/hook/src/lib/output.ts
    packages/hook/src/lib/config.ts
    packages/hook/src/index.ts
  </files>
  <action>
    Replace all 4 ternary operators in the hook package with ts-pattern match() expressions. Import P from ts-pattern where needed.

    **packages/hook/src/lib/output.ts** (2 ternaries):

    1. Line 19-21 — header selection ternary:
       ```
       // BEFORE:
       const header = required
         ? "**Missing Required Plugin Dependencies**"
         : "**Missing Optional Plugin Dependencies**";
       // AFTER:
       const header = match(required)
         .with(true, () => "**Missing Required Plugin Dependencies**")
         .with(false, () => "**Missing Optional Plugin Dependencies**")
         .exhaustive();
       ```

    2. Line 26 — optional description ternary:
       ```
       // BEFORE:
       const desc = dep.description ? ` - ${dep.description}` : "";
       // AFTER:
       const desc = match(dep.description)
         .with(P.string, (d) => ` - ${d}`)
         .otherwise(() => "");
       ```

    **packages/hook/src/lib/config.ts** (1 ternary):

    3. Line 39 — error message fallback:
       ```
       // BEFORE:
       const errorMessage = parseError instanceof Error ? parseError.message : "Parse error";
       // AFTER:
       const errorMessage = match(parseError)
         .with(P.instanceOf(Error), (e) => e.message)
         .otherwise(() => "Parse error");
       ```
       Add `P` to the existing ts-pattern import: `import { match, P } from "ts-pattern";`

    **packages/hook/src/index.ts** (1 ternary):

    4. Line 33 — crash-proof output fallback:
       ```
       // BEFORE:
       const output = error ? {} : response;
       // AFTER:
       const output = match({ error, response })
         .with({ error: P.nullish }, ({ response: r }) => r)
         .otherwise(() => ({}));
       ```
       Add `P` to the existing ts-pattern import: `import { match, P } from "ts-pattern";`
       Note: attemptAsync returns `[Error, undefined] | [null, T]`, so check for error being nullish (null) to get the success case.

    Do NOT change any other logic, signatures, or behavior. Purely mechanical ternary-to-match replacement.

  </action>
  <verify>
    1. Run `pnpm build` from repo root — must succeed with no errors
    2. Run `grep -rn '?' packages/hook/src/ | grep -v '//' | grep -v '\?:' | grep -v 'node_modules' | grep -v '.js:' | grep '?'` — confirm zero ternaries remain in hook src (only `?.` optional chaining and `??` nullish coalescing are acceptable)
    3. Run `pnpm typecheck` — no type errors
  </verify>
  <done>
    Zero ternary operators in packages/hook/src/. All 4 replaced with match() expressions. Build and typecheck pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace ternaries in CLI package (5 ternaries in 3 files)</name>
  <files>
    packages/cli/src/lib/config-loader.ts
    packages/cli/src/commands/init.ts
    packages/cli/src/commands/update.ts
  </files>
  <action>
    Replace all 5 ternary operators in the CLI package with ts-pattern match() expressions. Import P from ts-pattern where needed.

    **packages/cli/src/lib/config-loader.ts** (1 ternary):

    1. Line 48 — error message fallback (identical pattern to hook config.ts):
       ```
       // BEFORE:
       const errorMessage = parseError instanceof Error ? parseError.message : "Parse error";
       // AFTER:
       const errorMessage = match(parseError)
         .with(P.instanceOf(Error), (e) => e.message)
         .otherwise(() => "Parse error");
       ```
       Add `P` to the existing ts-pattern import: `import { match, P } from "ts-pattern";`

    **packages/cli/src/commands/init.ts** (2 ternaries):

    2. Line 103 — hook script action selection:
       ```
       // BEFORE:
       fileActions.push({
         path: "hook/anthropak.mjs",
         action: hookScriptExists ? "update" : "create",
       });
       // AFTER:
       fileActions.push({
         path: "hook/anthropak.mjs",
         action: match(hookScriptExists)
           .with(true, () => "update" as const)
           .with(false, () => "create" as const)
           .exhaustive(),
       });
       ```

    3. Line 131 — optional reason formatting:
       ```
       // BEFORE:
       const reason = action.reason ? ` (${action.reason})` : "";
       // AFTER:
       const reason = match(action.reason)
         .with(P.string, (r) => ` (${r})`)
         .otherwise(() => "");
       ```
       Ensure `P` is in the ts-pattern import: `import { match, P } from "ts-pattern";` (P is already imported in init.ts)

    **packages/cli/src/commands/update.ts** (2 ternaries):

    4. Line 32 — hook script action selection (identical pattern to init.ts):
       ```
       // BEFORE:
       fileActions.push({
         path: "hook/anthropak.mjs",
         action: hookScriptExists ? "update" : "create",
       });
       // AFTER:
       fileActions.push({
         path: "hook/anthropak.mjs",
         action: match(hookScriptExists)
           .with(true, () => "update" as const)
           .with(false, () => "create" as const)
           .exhaustive(),
       });
       ```
       Add `P` to the existing ts-pattern import: `import { match, P } from "ts-pattern";`

    5. Line 61 — optional reason formatting (identical pattern to init.ts):
       ```
       // BEFORE:
       const reason = action.reason ? ` (${action.reason})` : "";
       // AFTER:
       const reason = match(action.reason)
         .with(P.string, (r) => ` (${r})`)
         .otherwise(() => "");
       ```

    Do NOT change any other logic, signatures, or behavior. Purely mechanical ternary-to-match replacement.

  </action>
  <verify>
    1. Run `pnpm build` from repo root — must succeed with no errors
    2. Run `grep -rn '?' packages/cli/src/ | grep -v '//' | grep -v '\?:' | grep -v 'node_modules' | grep -v '.js:' | grep -v '.generated' | grep '?'` — confirm zero ternaries remain in CLI src (only `?.` optional chaining and `??` nullish coalescing are acceptable)
    3. Run `pnpm typecheck` — no type errors
  </verify>
  <done>
    Zero ternary operators in packages/cli/src/. All 5 replaced with match() expressions. Build and typecheck pass.
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` — full build succeeds (hook -> CLI pipeline)
2. `pnpm typecheck` — zero type errors
3. `pnpm lint` — zero lint errors (or only pre-existing acceptable ones)
4. Grep for ternaries across both packages confirms zero remaining:
   - `grep -rn ' ? ' packages/hook/src/ packages/cli/src/ --include='*.ts' | grep -v '^\s*//' | grep -v '\?\.' | grep -v '\?\?' | grep -v '.generated'` returns empty
5. Grep for match() usage confirms replacements exist:
   - `grep -rn '\.exhaustive()' packages/hook/src/ packages/cli/src/ --include='*.ts'` shows 22+ calls (was 22, adding ~6 more)
   - `grep -rn '\.otherwise(' packages/hook/src/ packages/cli/src/ --include='*.ts'` shows new otherwise() calls
</verification>

<success_criteria>

- Zero ternary operators in packages/hook/src/ and packages/cli/src/
- All 9 ternaries replaced with ts-pattern match() expressions
- Build pipeline works (hook -> CLI)
- TypeScript compiles with no errors
- HARD-01 requirement fully satisfied: all control flow uses ts-pattern
  </success_criteria>

<output>
After completion, create `.planning/phases/01-core-rebuild/01-03-SUMMARY.md`
</output>
