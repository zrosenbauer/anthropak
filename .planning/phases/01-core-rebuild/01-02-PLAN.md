---
phase: 01-core-rebuild
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/cli/package.json
  - packages/cli/src/types.ts
  - packages/cli/src/cli.ts
  - packages/cli/src/commands/default.ts
  - packages/cli/src/commands/init.ts
  - packages/cli/src/commands/update.ts
  - packages/cli/src/commands/validate.ts
  - packages/cli/src/lib/templates.ts
  - packages/cli/src/lib/hooks.ts
  - packages/cli/src/lib/fs.ts
  - packages/cli/src/lib/node-version.ts
  - packages/cli/src/templates/dependencies.yaml.liquid
  - packages/cli/scripts/build-assets.ts
autonomous: true

must_haves:
  truths:
    - "User running `anthropak init` sees auto-detected mode (plugin vs repo), confirms, then sees file summary and confirms before any files are written"
    - "User running `anthropak update` sees file summary and confirms before hook script is updated"
    - "User running `anthropak validate` sees detailed validation errors for malformed dependencies.yaml"
    - "CLI scaffolds dependencies.yaml with new nested schema (version: 1, plugins section with required/optional arrays)"
    - "CLI uses ts-pattern for all control flow and attemptAsync for all async operations — zero try-catch, zero ternaries"
    - "Full build pipeline works: hook builds first, CLI embeds hook output, CLI builds to dist/cli.mjs"
  artifacts:
    - path: "packages/cli/src/commands/init.ts"
      provides: "Init command with mode detection, confirmation prompts, file scaffolding"
      contains: "confirm"
    - path: "packages/cli/src/commands/update.ts"
      provides: "Update command with confirmation before writing"
      contains: "confirm"
    - path: "packages/cli/src/commands/validate.ts"
      provides: "Validate command with detailed error output"
      contains: "match"
    - path: "packages/cli/src/templates/dependencies.yaml.liquid"
      provides: "Template for new nested schema"
      contains: "version: 1"
    - path: "packages/cli/src/lib/fs.ts"
      provides: "File system helpers with attemptAsync"
      contains: "attemptAsync"
  key_links:
    - from: "packages/cli/src/commands/init.ts"
      to: "packages/cli/src/lib/templates.ts"
      via: "renderDependenciesYaml + getHookScript calls"
      pattern: "renderDependenciesYaml|getHookScript"
    - from: "packages/cli/src/commands/init.ts"
      to: "packages/cli/src/lib/hooks.ts"
      via: "hooks.json manipulation"
      pattern: "readHooksJson|addHookEntry|writeHooksJson"
    - from: "packages/cli/src/commands/validate.ts"
      to: "packages/cli/src/lib/config-loader.ts"
      via: "Config loading and validation with detailed errors"
      pattern: "loadConfig|validateConfig"
    - from: "packages/cli/scripts/build-assets.ts"
      to: "packages/hook/dist/anthropak.mjs"
      via: "Embeds hook output at build time"
      pattern: "anthropak.mjs"
---

<objective>
Rebuild the CLI package from scratch with proper patterns, confirmation prompts before all filesystem mutations, new schema template, mode detection for init, and a validate command.

Purpose: The CLI is how users set up and manage anthropak. It must confirm before writing files (per CONTEXT.md), support plugin vs repo modes for init, use the new nested schema, and provide a validate command for detailed config error reporting. All code uses ts-pattern and attemptAsync consistently.

Output: Complete `packages/cli` package rebuilt from scratch — yargs setup, init/update/validate commands with @clack/prompts confirmation, new schema template, build-assets script. Full build pipeline (hook -> CLI) produces working dist/cli.mjs.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-rebuild/01-CONTEXT.md
@.planning/phases/01-core-rebuild/01-RESEARCH.md
@.planning/phases/01-core-rebuild/01-01-SUMMARY.md

Reference existing build pipeline:
@packages/cli/tsdown.config.ts
@packages/cli/tsconfig.json
@packages/cli/package.json
@packages/cli/scripts/build-assets.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Types, templates, file helpers, and build pipeline</name>
  <files>
    packages/cli/package.json
    packages/cli/src/types.ts
    packages/cli/src/templates/dependencies.yaml.liquid
    packages/cli/src/lib/fs.ts
    packages/cli/src/lib/templates.ts
    packages/cli/src/lib/hooks.ts
    packages/cli/src/lib/node-version.ts
    packages/cli/scripts/build-assets.ts
  </files>
  <action>
**Update packages/cli/package.json:**
Add `ts-pattern` (^5.5.0) and `es-toolkit` (^1.44.0) to dependencies. Remove `liquidjs` from dependencies (we will replace the Liquid template with a simple string template — the template is trivially simple YAML and doesn't need a full template engine; this reduces dependencies and aligns with the es-toolkit philosophy of not over-engineering). Run `pnpm install`.

**Rewrite packages/cli/src/types.ts:**
- Re-export types from the hook package that CLI needs. Since both packages are in the same monorepo and the CLI embeds the hook at build time (not runtime dependency), define the types locally but keep them in sync. Copy the schema types from hook's types.ts (DependenciesConfig, EcosystemSection, PluginDependency, DependencyEntry, ValidationResult, ConfigLoadResult).
- Add CLI-specific types:
  - `InitMode = 'plugin' | 'repo'`
  - `InitOptions = { path: string; force: boolean }`
  - `UpdateOptions = { path: string }`
  - `ValidateOptions = { path: string }`
  - `FileAction = { path: string; action: 'create' | 'update' | 'skip'; reason?: string }`

**Rewrite packages/cli/src/templates/dependencies.yaml.liquid (rename conceptually — keep .liquid extension for now but content changes):**
Update template to use new nested schema per CONTEXT.md:
```yaml
# dependencies.yaml - Dependency declarations for anthropak
# Docs: https://github.com/zrosenbauer/anthropak

version: 1

plugins:
  required: []
    # - plugin: "example-plugin"
    #   github: "owner/repo"
    #   description: "What this plugin provides"
    #   install: "claude plugin add --git git@github.com:owner/repo.git"

  optional: []
    # - plugin: "nice-to-have-plugin"
    #   description: "Optional enhancement"
```

Note: Include commented examples showing all available fields. No `marketplace` field. No `cli` or `mcp` sections in template (they'll be added in Phase 2/3).

**Create packages/cli/src/lib/fs.ts (NEW file):**
File system helpers that use attemptAsync for all operations:

`readFileAsync(path: string): Promise<[Error | null, string | null]>`:
- Wrap `readFile` from `fs/promises` in attemptAsync
- Return the tuple directly

`writeFileAsync(path: string, content: string): Promise<[Error | null, void | null]>`:
- Wrap `writeFile` from `fs/promises` in attemptAsync

`mkdirAsync(path: string): Promise<[Error | null, void | null]>`:
- Wrap `mkdir` with `{ recursive: true }` in attemptAsync

`fileExists(path: string): Promise<boolean>`:
- Use attemptAsync with `access` from `fs/promises`
- Return true if no error, false if error

`chmodAsync(path: string, mode: number): Promise<[Error | null, void | null]>`:
- Wrap `chmod` from `fs/promises` in attemptAsync

All helpers use async fs (fs/promises), never sync. Zero try-catch.

**Rewrite packages/cli/src/lib/templates.ts:**
- Remove liquidjs dependency entirely
- `renderDependenciesYaml(): string` — just return the template string from `.generated/index.js` directly (no Liquid rendering needed since template has no dynamic parts)
- `getHookScript(): string` — return the embedded hook script from `.generated/index.js`
- Keep `HookEntry` interface and `HOOK_ENTRY` constant (same as current)

**Rewrite packages/cli/src/lib/hooks.ts:**
Same functionality but with attemptAsync and ts-pattern:
- `readHooksJson(path: string): Promise<HooksJson>` — use attemptAsync for file read + JSON parse, return empty structure on error
- `hookExists(hooksJson: HooksJson): boolean` — check if anthropak hook entry exists in SessionStart
- `addHookEntry(hooksJson: HooksJson): HooksJson` — add hook entry to SessionStart if not exists
- `writeHooksJson(path: string, hooksJson: HooksJson): Promise<void>` — use attemptAsync for file write
- Use match() for any control flow decisions. Zero try-catch.

**Rewrite packages/cli/src/lib/node-version.ts:**
Keep the Node.js version check middleware but rewrite using ts-pattern for the version comparison logic if there are conditionals. Use match() for branching on version check result.

**Update packages/cli/scripts/build-assets.ts:**
Keep the same structure (generate .generated/ files with version, template, hook script) but:
- Update to embed the new schema template (no Liquid syntax, just plain YAML string)
- Keep the hook script embedding (reads from packages/hook/dist/anthropak.mjs)
- Keep the version embedding (reads from package.json)
- The script itself can use sync fs (it's a build script, not runtime code)
  </action>
  <verify>
Run `pnpm typecheck` from packages/cli — should pass (may need .generated/ files to exist first; run `pnpm build:assets` after hook is built). Verify no try-catch: `grep -rn "try {" packages/cli/src/lib/` returns nothing. Verify liquidjs removed from package.json: `grep -c "liquidjs" packages/cli/package.json` returns 0. Verify template has `version: 1`: `grep "version: 1" packages/cli/src/templates/dependencies.yaml.liquid`.
  </verify>
  <done>
Types defined with CLI-specific additions. Template updated to new nested schema. File helpers use attemptAsync exclusively. hooks.ts and templates.ts rewritten with proper patterns. liquidjs dependency removed. Build-assets script updated for new template format.
  </done>
</task>

<task type="auto">
  <name>Task 2: CLI commands (init, update, validate) with confirmation prompts</name>
  <files>
    packages/cli/src/cli.ts
    packages/cli/src/commands/default.ts
    packages/cli/src/commands/init.ts
    packages/cli/src/commands/update.ts
    packages/cli/src/commands/validate.ts
  </files>
  <action>
**Rewrite packages/cli/src/commands/init.ts from scratch:**

Per CONTEXT.md locked decisions:
- Scaffold only — create empty config files, no interactive wizard
- Two modes: **plugin** (distributed plugin) and **repo** (any codebase)
- Auto-detect mode, confirm with user
- Summary + confirm before writing files

Implementation:
1. **Detect mode** with a `detectMode(rootDir: string): InitMode` function:
   - Check for plugin markers: existing `hooks.json`, `.claude-plugin/` directory, `plugin.json` → suggests 'plugin' mode
   - Otherwise default to 'repo' mode
   - Use ts-pattern `match()` on detection signals

2. **Confirm mode** with @clack/prompts:
   - `intro('anthropak init')` to start
   - Show detected mode: `log.info('Detected mode: plugin')`
   - `confirm({ message: 'Use plugin mode?', initialValue: true })` — let user override
   - Handle cancellation (check for `Symbol.for('clack:cancel')`)

3. **Build file action list:**
   - `dependencies.yaml` — create (or skip if exists and no --force)
   - `hook/anthropak.mjs` — create or update
   - `hooks.json` — create or update
   - Use `fileExists()` from fs.ts to check what exists
   - Build `FileAction[]` array with path, action, and skip reason

4. **Show summary + confirm** before writing:
   - List each file with its action (create/update/skip) using `log.info()` or `log.step()`
   - `confirm({ message: 'Proceed?', initialValue: false })` — default No per CONTEXT.md
   - Abort if not confirmed

5. **Write files** with attemptAsync:
   - Create hook/ directory with `mkdirAsync`
   - Write dependencies.yaml from template using `writeFileAsync`
   - Write hook/anthropak.mjs from embedded script using `writeFileAsync`
   - Set hook script executable with `chmodAsync`
   - Update hooks.json using hooks.ts helpers
   - Report success/failure for each file

6. **Outro:** `outro('Edit dependencies.yaml to declare your dependencies.')`

Use match() for all branching. attemptAsync for all file operations. Zero try-catch.

**Rewrite packages/cli/src/commands/update.ts from scratch:**

Per CONTEXT.md: CLI prompts for confirmation before filesystem mutations.

1. `intro('anthropak update')`
2. Build file action list: hook/anthropak.mjs (update), hooks.json (update if needed)
3. Show summary of what will be updated
4. `confirm({ message: 'Proceed?', initialValue: false })`
5. Write files with attemptAsync
6. `outro('Done')`

Same patterns: match() for control flow, attemptAsync for file ops.

**Create packages/cli/src/commands/validate.ts (NEW file):**

Per CONTEXT.md: CLI commands get "more verbose errors with detailed suggestions."

1. Load config using the same loading logic as the hook (import from shared config loader or duplicate the loading/validation logic locally — since CLI can't import from hook at runtime, duplicate the config loading code or create a shared loader in cli/src/lib/):
   - Create `packages/cli/src/lib/config-loader.ts` that duplicates the config loading/validation logic from hook (same confbox parsing, same validation, same types). This duplication is acceptable because:
     - Hook and CLI have different runtime environments (hook is bundled to single file, CLI is a separate build)
     - The validation logic is the source of truth in hook, CLI copies it
     - In future, could extract to shared package

   Actually, simpler approach: the CLI can import confbox directly (it's already a dependency of the hook, and CLI can add it too). Add confbox to CLI dependencies and duplicate the loadConfig + validateConfig functions in a cli/src/lib/config-loader.ts file, using the same types from cli/src/types.ts.

2. `validate` command:
   - `intro('anthropak validate')`
   - Load config from path
   - Use match() on ConfigLoadResult:
     - `{ status: 'not_found' }` → `log.error('No dependencies.yaml found')` + suggest `anthropak init`
     - `{ status: 'parse_error' }` → `log.error('Parse error: {message}')` + show which file failed
     - `{ status: 'validation_error' }` → list each error with `log.error()` + provide fix suggestions
     - `{ status: 'success' }` → `log.success('dependencies.yaml is valid')` + show summary (N required, M optional plugins)
   - `outro()` with appropriate message

**Rewrite packages/cli/src/commands/default.ts from scratch:**
- Auto-detect whether initialized (check for dependencies.yaml + hook/)
- Use match() on detection result to delegate to init or update
- Use attemptAsync for file existence checks

**Rewrite packages/cli/src/cli.ts from scratch:**
- Keep yargs setup (per CONTEXT.md: Claude's discretion, keep yargs for Phase 1)
- Register commands: default, init, update, validate (NEW)
- Keep version, help, strict mode
- Import VERSION from .generated/index.js
- Keep node-version middleware

IMPORTANT: Every command must use @clack/prompts for user interaction. Every file operation must use attemptAsync. Every control flow branch must use ts-pattern match(). Zero try-catch. Zero ternaries. Zero nested if/else.
  </action>
  <verify>
Run `pnpm build` from repo root (builds hook first, then CLI) — should succeed. Verify zero try-catch: `grep -rn "try {" packages/cli/src/` returns nothing. Verify confirm() is called before file writes in init.ts and update.ts: `grep -c "confirm" packages/cli/src/commands/init.ts` returns >= 1, same for update.ts. Verify validate command exists: `ls packages/cli/src/commands/validate.ts`. Run `pnpm typecheck` from packages/cli.
  </verify>
  <done>
Complete CLI package rebuilt. Init command detects plugin/repo mode, confirms with user, shows file summary, confirms before writing. Update command confirms before writing. Validate command provides detailed error output. Default command auto-detects and delegates. All commands use @clack/prompts, ts-pattern, attemptAsync. Zero try-catch, zero ternaries. Full build pipeline works (hook -> CLI).
  </done>
</task>

</tasks>

<verification>
1. `pnpm build` from repo root succeeds — hook builds to dist/anthropak.mjs, CLI builds to dist/cli.mjs
2. `pnpm typecheck` passes in both packages with zero errors
3. `grep -rn "try {" packages/cli/src/` returns zero matches
4. `grep -rn "catch" packages/cli/src/` returns zero matches
5. Init command has two confirmation points: mode confirmation and file write confirmation
6. Update command confirms before writing files
7. Validate command exists and provides detailed error output using match()
8. Template produces valid dependencies.yaml with `version: 1` and `plugins` section
9. liquidjs is not in CLI package.json dependencies
10. `confirm` from @clack/prompts is used in init.ts and update.ts
</verification>

<success_criteria>
- Full build pipeline works: `pnpm build` from root produces both dist/anthropak.mjs and dist/cli.mjs
- Init command: detects plugin vs repo mode, confirms with user, shows file list, confirms before writes
- Update command: shows what will change, confirms before writes
- Validate command: loads config, shows detailed validation results with suggestions
- Template uses new nested schema (version: 1, plugins section)
- All CLI code uses ts-pattern for control flow — zero ternaries, zero nested if/else
- All CLI async operations use attemptAsync — zero try-catch
- liquidjs dependency removed, replaced with simple string template
- @clack/prompts used for all user-facing confirmations
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-rebuild/01-02-SUMMARY.md`
</output>
