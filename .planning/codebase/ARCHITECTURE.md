# Architecture

**Analysis Date:** 2026-02-06

## Pattern Overview

**Overall:** Monorepo with two-package build pipeline. The hook package is a zero-dependency validation utility bundled into the CLI tool. The CLI embeds the hook at build time and provides interactive scaffolding and management commands.

**Key Characteristics:**
- Declarative dependency specification in YAML/JSON config files
- Compile-time asset embedding (hook script bundled into CLI)
- Two-stage validation: config parsing + plugin registry checking
- CLI drives initialization and updates; hook runs passively in Claude Code

## Layers

**Hook Package (`@anthropak/hook`):**
- Purpose: Validates declared plugin dependencies against Claude's installed plugin registry at runtime
- Location: `packages/hook/src/`
- Contains: Config loading, validation, registry checking, and formatted output generation
- Depends on: `confbox` (config parser), Node.js fs/path modules
- Used by: Claude Code hook system; bundled into CLI and executed by Claude when loading plugins

**CLI Package (`anthropak`):**
- Purpose: User-facing tool to scaffold, initialize, and update plugin dependency configurations
- Location: `packages/cli/src/`
- Contains: Command definitions, template rendering, hooks.json management, asset generation
- Depends on: `@clack/prompts` (interactive UI), `yargs` (CLI parsing), `liquidjs` (template rendering), hook package output
- Used by: Plugin developers running `anthropak init` or `anthropak update` commands

**Generated Assets Layer:**
- Purpose: Embed runtime assets to enable standalone binary distribution
- Location: `packages/cli/src/.generated/`
- Contains: Version string, dependencies.yaml template, bundled hook script
- Generated by: `packages/cli/scripts/build-assets.ts` prebuild script
- Used by: CLI commands inject assets into generated configurations

## Data Flow

**Hook Execution Flow (Runtime):**

1. Claude Code plugin initialization loads `hooks.json`
2. Hook system invokes `hook/anthropak.mjs` with stdin containing plugin context
3. Hook reads `dependencies.yaml` from plugin root
4. Hook loads Claude's `installed_plugins.json` registry (from Claude's storage)
5. Hook validates config structure and checks each declared dependency against registry
6. Hook generates JSON response with `systemMessage` if dependencies missing
7. Hook outputs JSON response to stdout
8. Claude displays message (or shows nothing if all dependencies satisfied)

**CLI Initialization Flow (Development):**

1. Developer runs `anthropak init [path]`
2. CLI prompts for configuration (via @clack/prompts)
3. CLI creates `hook/` directory
4. CLI renders `dependencies.yaml` from embedded template
5. CLI writes hook script from embedded HOOK_SCRIPT constant
6. CLI updates/creates `hooks.json` with anthropak hook entry
7. CLI exits; developer manually edits `dependencies.yaml`

**Config Validation Flow:**

1. Load raw config file (YAML/JSON/JSONC supported)
2. Validate structure: `dependencies` root object with `required`/`optional` arrays
3. Validate each dependency: has `plugin` string, optional fields are strings
4. Transform to `PluginDependency[]` objects
5. Return `ValidationResult` with errors or parsed dependencies

**Registry Checking Flow:**

1. Load installed plugins registry from `installed_plugins.json`
2. For each declared dependency:
   - If marketplace specified: check exact `plugin@marketplace` key exists with global or covering project installation
   - If no marketplace: check any `plugin@*` key exists with covering installation
3. Return missing dependencies (required vs optional)
4. Format missing as markdown with install commands

**State Management:**
- Configuration: Declarative YAML/JSON files (mutable by developers)
- Registry: Claude's centralized `installed_plugins.json` (read-only from hook perspective)
- Generated assets: Embedded in CLI binary at build time (immutable at runtime)
- Hook directory: Contains hook script and dependencies.yaml (together define plugin's dependency contract)

## Key Abstractions

**PluginDependency:**
- Purpose: Represents a single declared plugin dependency with metadata
- Files: `packages/hook/src/types.ts`
- Pattern: Minimal interface with optional fields for marketplace, github, description, install command
- Used in: Config validation, registry checking, output formatting

**ValidationResult:**
- Purpose: Type-safe representation of config validation outcome
- Files: `packages/hook/src/types.ts`
- Pattern: Discriminated union (valid boolean determines presence of data vs errors)
- Used in: Hook main flow to branch on validation success/failure

**InstalledPluginsRegistry:**
- Purpose: Maps Claude's installed plugins by key (plugin@marketplace format) to installation records
- Files: `packages/hook/src/types.ts` (type), `packages/hook/src/lib/registry.ts` (loader)
- Pattern: Flat object structure with plugin key -> installation array mapping
- Scope handling: Global installations apply everywhere; project installations check path coverage

**Command Module:**
- Purpose: Encapsulates CLI command definitions (init, update, default)
- Files: `packages/cli/src/commands/{init,update,default}.ts`
- Pattern: Yargs CommandModule interface with builder/handler pair
- Pattern: Prompts via @clack/prompts, filesystem operations, JSON/YAML manipulation

## Entry Points

**Hook Entry Point:**
- Location: `packages/hook/src/index.ts`
- Triggers: Claude Code plugin system on plugin load (from hooks.json configuration)
- Responsibilities:
  1. Read stdin containing plugin context
  2. Load dependencies.yaml from plugin root
  3. Validate config structure
  4. Check installed plugins registry
  5. Format and output JSON response with optional systemMessage
  6. Exit cleanly (never throw; always output valid JSON or empty object)

**CLI Entry Point:**
- Location: `packages/cli/src/cli.ts` (shebang: `#!/usr/bin/env node`)
- Triggers: `anthropak` command in terminal
- Responsibilities:
  1. Parse command-line arguments with yargs
  2. Validate Node version (>=18.0.0)
  3. Dispatch to subcommand handlers (init, update, default/help)
  4. Handle version/help flags

**Build Entry Point:**
- Location: `packages/cli/scripts/build-assets.ts`
- Triggers: `pnpm build:assets` (called as prebuild before `pnpm build`)
- Responsibilities:
  1. Read hook package's dist/anthropak.mjs
  2. Read dependencies.yaml.liquid template
  3. Read package.json version
  4. Generate src/.generated/{hook,template,version}.ts with escaped content
  5. Exit with error if hook or template missing (enforces build order)

## Error Handling

**Strategy:** Fail gracefully with minimal output. Hook never crashes; always returns JSON.

**Patterns:**

- Hook catches all exceptions in try/catch wrapper; outputs empty JSON object on error
- Config loading returns null if file not found or parse fails
- Registry loading returns DEFAULT_REGISTRY (empty) if file missing or invalid
- Validation collects all errors before returning; doesn't fail fast
- CLI commands prompt users; catch filesystem errors and log them
- Prebuild script exits with code 1 if assets missing (unambiguous build failure signal)

## Cross-Cutting Concerns

**Logging:**
- Hook: None (only JSON output to stdout)
- CLI: Interactive prompts via @clack/prompts (intro/outro messages, log.info/success/warn levels)

**Validation:**
- Hook: Two-stage (config structure, then registry matching)
- CLI: File existence checks, directory creation with recursive flag, Yargs type validation on args

**Authentication:**
- None. Hook reads Claude's internal installed_plugins.json directly (no API calls)
- CLI reads/writes user project files (dependencies.yaml, hooks.json, hook/anthropak.mjs)

**Build Dependencies:**
- Hook builds first via turbo dependency (`build: { dependsOn: ["^build"] }`)
- CLI prebuild reads hook's dist/anthropak.mjs
- CLI build then consumes generated assets
- Turbo enforces order; build fails if hook missing before CLI prebuild runs

---

*Architecture analysis: 2026-02-06*
